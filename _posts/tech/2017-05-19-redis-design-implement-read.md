---
layout: post
title:  &lt;&lt;Redis 设计与实现&gt;&gt; 读后感 
tags: [tech]
city: 杭州 
---


<<Redis 设计与实现>> 读后感
=============
+ 数据结构篇



第二部分 单机数据库的实现
------------------------
+ 数据库
    + 过期键删除的策略
        + 定时删除：设置timer函数，设置过期时间后，对数据进行删除，虽然对数据库的体积控制最好，但是占用大量cpu时间
        + 惰性删除：只有再次访问数据的时候，通过判断是否已经失效，如果失效，调用函数删除key，但缺点如果没有再次访问，数据会积累；
        + 定期删除：建立定时任务，扫描整个数据库的数据键，判断是否为失效；如果为失效则删除；删除太频繁，占用cpu；删除时间太长，则浪费内存（数据体积增大）
        + redis使用的是：惰性删除和定期删除；
    + 持久化对过期键处理策略
        + 同步到磁盘中的时候，会判断键是否已经过期，过期则不保留
        + 从磁盘中载入的时候，判断键是否已经过期，过期则不载入
    + 同步删除键
        + 从server显示的发出DEL命令，同步从服务器中，从服务器只有接收到主服务器删除命令，才会删除，否则，读取数据正常
+ 持久化
    + RDB持久化
        + 保存redis储存数据的信息
        + SAVE:持久化过程是阻塞主线程，redis无法正常提供服务
        + BGSAVE:fork主进程，将redis内容直接保存在磁盘中，redis可正常提供服务，这样做有两个缺点；内存double；数据很容易不同步
        + 优先级小于AOF文件，如果存在AOF文件，优先从AOF载入
         
        + ```c
        save 900 1 // 如果服务器在900秒内，处理一条以上数据，触发save命令
        save 300 10 // 服务器300秒内，处理10条以上数据，触发save命令
        save 60 10000
        //上面保存多个配置数据，redis间隔时间循环判断是否需要保存
        struct redisServer {
            // 从上一次save命令发生后，总共的操作次数
            long long dirty;
            // 最近一次保存的时间
            time_t lastsave;
        }
        ```
        + RDB文件结构部分
    + AOF持久化
        + 保存redis所执行的写命令操作
        + 同步方式：
            + 追加(append)
            + 文件写入
            + 文件同步(sync)
        + 将命令写入一个aof_buf缓存区,转换为协议格式，存入缓存区;
        + appendfync选项不同含义
        
        
			|  appendfync 选项的值 | flushAppendOnlyFile函数的行为   | 安全度 |
			| ------------------------ | ------------------------------------ |--------------|
			|	always   |  将aof_buf缓存区的所有内容写入实时同步到AOF文件中   |高，但带来大量系统频繁写入磁盘操作|
			|   everysec|  有独立线程，判断两次同步操作是否超过1秒钟，如果超过启动同步操作  | 中等 |
			|   no         |   将aof_buf缓存去的所有内容写入同步文件，但不进行同步操作，何时同步交给系统来做  | 低，如果系统宕机；缓存的内容将丢失|
		+ 重载AOF文件过程，redis建立一个虚拟的客户端，将AOF命令解析出来，通过虚拟客户端执行；
		+ AOF重写功能；消除老AOF中过期命令，达到AOF文件瘦身的功能
+ 事件
    + 系统解耦通过消息机制实现，上面无需管下面实现思路，但是提供了一个可以相应的消息
    + 文件事件
        

